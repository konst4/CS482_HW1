<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Cs482 hw1 by konst4</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Cs482 hw1</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/konst4/CS482_HW1" class="btn">View on GitHub</a>
      <a href="https://github.com/konst4/CS482_HW1/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/konst4/CS482_HW1/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CS 482 HW 1</h3>

<p>The first step of the program was to load the original image. Then the resize operation will scale, the image to 512 by 512. After this operation, the image needed to be split into three components using the split function. After this step , a Gaussian filter should be applied. The kernel size that I defined was 15 by 15. The next step was to apply the filter using the different sigma values of 1, 2, and 3 on the three different color component images. After applying the Filter, the next step was to merge the three different components together for each sigma value to get the colored image but more smoothed and  with less noise. The greater the sigma value the more blurry the image became(less noisy). The next step was to take the derivatives of these newly smoothed images as well as the original. OpenCV has a great function called Sobel. After getting the derivatives in the x and in the "y" direction. It was time to do some edge detection(hopefully this means the magnitude of images). There is a function called Canny which uses the algorithm in class, that we discussed. By changing the gradient size more detail was  either gained or lost. The last part was to write all of our newly made images to files to share them . </p>

<h3>
<a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CODE:</h3>

<p>import cv2<br>
import numpy as np<br>
from matplotlib import pyplot as plt<br>
import os<br>
<br>
#Resized image to 512x512<br>
img = cv2.imread('me.jpg')<br>
src=cv2.resize(img,(512,512))<br>
<br>
#First split the image into the three color channels r,g,b.<br>
#Online it said it may be useful to use hsv due to its range and intensity property?<br>
b,g,r =cv2.split(src)<br>
<br>
#we now have three images to work with b , g , and r<br>
#need to apply Gaussian filters for Sigma 1,2,3<br>
#Simga=1<br>
blur_blue1=cv2.GaussianBlur(b,(15,15),1)<br>
blur_green1=cv2.GaussianBlur(g,(15,15),1)<br>
blur_red1=cv2.GaussianBlur(r,(15,15),1)<br>
<br>
#Sigma=2<br>
blur_blue2=cv2.GaussianBlur(b,(15,15),2)<br>
blur_green2=cv2.GaussianBlur(g,(15,15),2)<br>
blur_red2=cv2.GaussianBlur(r,(15,15),2)<br>
<br>
#Sigma=3<br>
blur_blue3=cv2.GaussianBlur(b,(15,15),3)<br>
blur_green3=cv2.GaussianBlur(g,(15,15),3)<br>
blur_red3=cv2.GaussianBlur(r,(15,15),3)<br>
<br>
#Now we have the different filtered images for different sigma values<br>
#Time to merge the values<br>
merged_sigma1=cv2.merge([blur_blue1,blur_green1,blur_red1])<br>
merged_sigma2=cv2.merge([blur_blue2,blur_green2,blur_red2])<br>
merged_sigma3=cv2.merge([blur_blue3,blur_green3,blur_red3])<br>
<br>
#looks good we can see that the it gets blurrier with a greater sigma value<br>
#Three derivatives of the different sigma values<br>
#X derivative<br>
derivative_xoriginal=cv2.Sobel(src,cv2.CV_64F,1,0,ksize=5)<br>  
derivative_x1=cv2.Sobel(merged_sigma1,cv2.CV_64F,1,0,ksize=5)<br>
derivative_x2=cv2.Sobel(merged_sigma2,cv2.CV_64F,1,0,ksize=5)<br>
derivative_x3=cv2.Sobel(merged_sigma3,cv2.CV_64F,1,0,ksize=5)<br>
<br>
#Y derivative<br>
derivative_yoriginal=cv2.Sobel(src,cv2.CV_64F,0,1,ksize=5)<br>
derivative_y1=cv2.Sobel(merged_sigma1,cv2.CV_64F,0,1,ksize=5)<br>
derivative_y2=cv2.Sobel(merged_sigma2,cv2.CV_64F,0,1,ksize=5)<br>
derivative_y3=cv2.Sobel(merged_sigma3,cv2.CV_64F,0,1,ksize=5)<br>
<br>
#magnitude images<br>
edge_original=cv2.Canny(src,100,100,5)<br>
edge_merge1=cv2.Canny(merged_sigma1,100,100,5)<br>
edge_merge2=cv2.Canny(merged_sigma2,100,100,5)<br>
edge_merge3=cv2.Canny(merged_sigma3,100,100,5)<br>
<br>
#write images to filesystem<br>
<br>
if(os.path.isdir('output')==False):<br>
   &#9;os.mkdir('output')<br>
<br>
os.chdir('output')<br>
cv2.imwrite('Resized.jpg',src)<br>
cv2.imwrite('Gaussian_Sigma1.jpg',merged_sigma1)<br>
cv2.imwrite('Gaussian_Sigma2.jpg',merged_sigma2)<br>
cv2.imwrite('Gaussian_Sigma3.jpg',merged_sigma3)<br>
cv2.imwrite('Derivative_X_original.jpg',derivative_xoriginal)<br>
cv2.imwrite('Derivative_X_Sigma1.jpg',derivative_x1)<br>
cv2.imwrite('Derivative_X_Sigma2.jpg',derivative_x2)<br>
cv2.imwrite('Derivative_X_Sigma3.jpg',derivative_x3)<br>
cv2.imwrite('Derivative_Y_original.jpg',derivative_yoriginal)<br>
cv2.imwrite('Derivative_Y_Sigma1.jpg',derivative_y1)<br>
cv2.imwrite('Derivative_Y_Sigma2.jpg',derivative_y2)<br>
cv2.imwrite('Derivative_Y_Sigma3.jpg',derivative_y3)<br>
cv2.imwrite('Edge_orginal.jpg',edge_original)<br>
cv2.imwrite('Edge_merge1.jpg',edge_merge1)<br>
cv2.imwrite('Edge_merge2.jpg',edge_merge2)<br>
cv2.imwrite('Edge_merge3.jpg',edge_merge3)<br>
<br>
<br>
<br>
cv2.waitKey(0);<br>
<br>
cv2.destroyAllWindows()<br></p>

<h3>
<a id="creating-pages-manually" class="anchor" href="#creating-pages-manually" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creating pages manually</h3>

<p>If you prefer to not use the automatic generator, push a branch named <code>gh-pages</code> to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.</p>

<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>You can @mention a GitHub username to generate a link to their profile. The resulting <code>&lt;a&gt;</code> element will link to the contributor’s GitHub Profile. For example: In 2007, Chris Wanstrath (<a href="https://github.com/defunkt" class="user-mention">@defunkt</a>), PJ Hyett (<a href="https://github.com/pjhyett" class="user-mention">@pjhyett</a>), and Tom Preston-Werner (<a href="https://github.com/mojombo" class="user-mention">@mojombo</a>) founded GitHub.</p>

<h3>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Having trouble with Pages? Check out our <a href="https://help.github.com/pages">documentation</a> or <a href="https://github.com/contact">contact support</a> and we’ll help you sort it out.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/konst4/CS482_HW1">Cs482 hw1</a> is maintained by <a href="https://github.com/konst4">konst4</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
